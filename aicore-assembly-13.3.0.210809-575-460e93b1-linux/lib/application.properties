# ----------------------------- Configuration -----------------------------
# The gRPC port of the server where the Config Service is running.
# Refreshable: `False`.
ataccama.client.connection.config-service.grpc.port=null

# The IP address or the URL of the server where the Config Service is running.
# Refreshable: `False`.
ataccama.client.connection.config-service.host=null

# The maximum size of gRPC message. KB are used if no unit is specified.
# Refreshable: `False`.
ataccama.client.grpc.properties.max-message-size=1GB

# Defines the minimum amount of time after which the microservices signal to the Configuration Service that
# they are alive. Expressed in seconds.
# Refreshable: `False`.
ataccama.config-service.heartbeat-interval=30

# Defines the minimum amount of time after which the microservices send a new request to retrieve properties
# from the Configuration Service. Expressed in seconds.
# Refreshable: `False`.
ataccama.config-service.refresh-interval=30

# The location of the `artifact-version.txt` containing resolved version of AI Core application.
# Refreshable: `False`.
ataccama.one.aicore.artifact-version-txt.location=${ataccama.path.doc}/artifact-version.txt

# The path to the `etc/application.properties` file.
# Refreshable: `False`.
ataccama.one.aicore.config.etc-location=${ataccama.path.etc}/application.properties

# The path to the `manage.py` file, which is used to start microservices/processes of AI Core.
# Refreshable: `False`.
ataccama.one.aicore.manage-py.location=${ataccama.path.lib}/manage.py

# The location of the `doc` folder of the AI Core application.
# Refreshable: `False`.
ataccama.path.doc=${ataccama.path.root}/doc

# The location of the etc folder of the AI Core application. The `etc/application.properties` path is relative
# to this path. The default value of this property can be overwritten only through environment variables and
# the default `application.properties` file. Otherwise, the change is ignored, which can lead to unexpected
# behavior.
# Refreshable: `False`.
ataccama.path.etc=${ataccama.path.root}/etc

# The location of the `log` folder of the AI Core application.
# Refreshable: `False`.
ataccama.path.log=${ataccama.path.root}/log

# The location of the `migrations` folder of the AI Core application.
# Refreshable: `False`.
ataccama.path.migrations=${ataccama.path.lib}/migrations

# The location of the `tmp` folder of the AI Core application.
# Refreshable: `False`.
ataccama.path.tmp=${ataccama.path.root}/temp

# ----------------------------- Health -----------------------------
# The timeout period during which the microservice and its subcomponents need to report as running, otherwise
# the whole microservice becomes unhealthy and its status changes to DOWN. The microservice also proactively shuts
# itself down when it registers such a situation.
# Refreshable: `False`.
ataccama.one.aicore.heartbeat_timeout=120

# ----------------------------- Logging -----------------------------
# Enables JSON console appender. Only one console appender can be enabled at a time.
# Refreshable: `False`.
#ataccama.logging.json-console-appender=

# Enables JSON file appender. Only one file appender can be enabled at a time.
# Refreshable: `False`.
#ataccama.logging.json-file-appender=

# Enables plain text console appender. Only one console appender can be enabled at a time.
# Refreshable: `False`.
#ataccama.logging.plain-text-console-appender=

# Enables plain text file appender. Only one file appender can be enabled at a time.
# Refreshable: `False`.
#ataccama.logging.plain-text-file-appender=

# A compression or archive format to which log files should be converted when they are closed.
# Refreshable: `False`.
ataccama.one.aicore.logging.compression=zip

# The name of the file used by the file appender.
# Refreshable: `False`.
ataccama.one.aicore.logging.filename=${ataccama.path.log}/aicore_{self.name}.log

# Indicates how often the current log file should be closed and a new one started.
# Refreshable: `False`.
ataccama.one.aicore.logging.rotation=4 days

# The minimum severity level starting from which logged messages are sent to the sink.
# Refreshable: `False`.
root.level=INFO

# ----------------------------- Retrying -----------------------------
# Controls retrying of gRPC and graphQL communication attempts. The property determines when retrying stops.
# By default, retrying stops after 6 attempts in total, out of which 5 are retries.
# Refreshable: `False`.
ataccama.one.aicore.retrying.stop.kwargs={"max_attempt_number": 6}

# Controls retrying of gRPC and graphQL communication attempts. The property determines which approach is used to
# stop retrying. For more information, see the
# [Tenacity API Reference](https://tenacity.readthedocs.io/en/latest/api.html), Stop Functions section.
# Refreshable: `False`.
ataccama.one.aicore.retrying.stop.type=stop_after_attempt

# Controls retrying of gRPC and graphQL communication attempts. The property is used to calculate the duration of
# waiting periods between retries. For more information about how waiting periods between unsuccessful attempts
# are managed, see the [Tenacity API Reference](https://tenacity.readthedocs.io/en/latest/api.html),
# Wait Functions section.
# Refreshable: `False`.
ataccama.one.aicore.retrying.wait.kwargs={"multiplier": 0.16, "exp_base": 2}

# Controls retrying of gRPC and graphQL communication attempts. The property determines which approach is used
# when waiting. For more information about how waiting periods between unsuccessful attempts are managed, see the
# [Tenacity API Reference](https://tenacity.readthedocs.io/en/latest/api.html), Wait Functions section.
# Refreshable: `False`.
ataccama.one.aicore.retrying.wait.type=wait_exponential

# ----------------------------- Wait for readiness on start -----------------------------
# Sets for how many seconds the microservice waits after requesting health information about its dependencies,
# for example, when the Recommender waits for the Neighbors or the Autocomplete waits for MMM.
# For more information, see the
# [Requests Developer Interface Documentation](https://requests.readthedocs.io/en/master/api/),
# section about the `timeout` parameter.
# Refreshable: `False`.
ataccama.one.aicore.onstart.health.response-timeout=5

# Defines the behavior of the microservice while it waits on a dependency before starting. Keyword arguments
# (kwargs) are the arguments used to construct an instance of the specified wait type. In this case, the keyword
# argument sets the duration of waiting intervals.
# Refreshable: `False`.
ataccama.one.aicore.onstart.retrying.wait.kwargs={"wait": 2.5}

# Defines the behavior of the microservice while it waits on a dependency before starting. Currently, the
# microservice either waits to receive information about the health of the dependency or the database readiness
# (typically, this means waiting for the database to start and for MMM to create the tables needed). The property
# defines how waiting periods are managed between unsuccessful attempts to verify the readiness of the dependency.
# For a list of other available wait types, see the
# [Tenacity API Reference](https://tenacity.readthedocs.io/en/latest/api.html), Wait Functions section.
# Refreshable: `False`.
ataccama.one.aicore.onstart.retrying.wait.type=wait_fixed

# ----------------------------- DB -----------------------------
# Used to define the AI Core database connection configuration.
# Supported dialects: postgresql.
# Additional properties include the following:
# `ataccama.one.aicore.database.connection.dialect=postgres`
# `ataccama.one.aicore.database.connection.host=localhost:5432/ai`
# `ataccama.one.aicore.database.connection.username=one`
# `ataccama.one.aicore.database.connection.password=one`
# Refreshable: `False`.
ataccama.one.aicore.database.connection=null

# Sets the SQLAlchemy engine options, such as the maximum length of identifiers used in the database. For more
# information, see the [Engine Configuration](https://docs.sqlalchemy.org/en/13/core/engines.html), section Engine
# Creation API, Parameters.
# Refreshable: `False`.
ataccama.one.aicore.database.engine-kwargs={"max_identifier_length": 128}

# Defines how often the database is polled for changes. Used by the Term Suggestions microservice. Expressed in
# seconds.
# Refreshable: `False`.
ataccama.one.aicore.database.poll-period=1

# ----------------------------- GraphQL -----------------------------
# Defines after which amount of time the HTTP call is ended if the socket does not receive any bytes.
# Expressed in seconds.
# Refreshable: `False`.
ataccama.one.aicore.http.connect-timeout=5

# ----------------------------- MMM -----------------------------
# The gRPC port of the server where the MMM is running.
# Refreshable: `False`.
ataccama.client.connection.mmm.grpc.port=8521

# The IP address or the URL of the server where the MMM is running.
# Refreshable: `False`.
ataccama.client.connection.mmm.host=localhost

# The HTTP port of the server where the MMM is running.
# Refreshable: `False`.
ataccama.client.connection.mmm.http.port=8021

# ----------------------------- Authentication - out -----------------------------
# The private key of the AI Core module used to generate tokens for internal JWT authentication.
# Refreshable: `False`.
#ataccama.authentication.internal.jwt.generator.key=

# Defines the amount of time after which the token generated by the internal JWT generator expires.
# Expressed in seconds.
# Refreshable: `False`.
ataccama.authentication.internal.jwt.generator.token-expiration=900

# ----------------------------- Parallelism -----------------------------
# An alternative way of overriding the number of parallel threads spawned by low-level calculations that are
# used by machine learning algorithms.
# If the value is set to `0`, all CPU cores run without hyper-threads.
# If the value is not set (`null`), other properties are not overridden.
# Relies on the static OpenBLAS API and might be ignored depending on the compilation options for the OpenBLAS library.
# When this property is set, OpenBLAS gives it higher priority compared to `ataccama.one.aicore.parallelism.omp`.
# This is intended only for exceptional cases and should not be used otherwise.
# Refreshable: `False`.
ataccama.one.aicore.parallelism.blas=null

# The number of parallel threads or processes spawned by high-level machine learning algorithms with explicit
# job management. If the value is set to `0`, all CPU cores run without hyper-threads.
# If the value is not set (`null`), the library default settings are applied.
# Use this option together with `ataccama.one.aicore.parallelism.omp`.
# For more information, see the AI Core Sizing Guidelines.
# Refreshable: `False`.
ataccama.one.aicore.parallelism.jobs=1

# The number of parallel threads spawned by low-level calculations that are used by high-level machine learning algorithms.
# If the value is set to `0`, all CPU cores run without hyper-threads.
# If the value is not set (`null`), the library default settings are applied.
# The property relies on the static OpenBLAS API and OpenMP API, which have a lower overhead than the dynamic API
# used by the property `ataccama.one.aicore.parallelism.threads`.
# When this property is set, the OpenBLAS library gives it lower priority compared to `ataccama.one.aicore.parallelism.blas`.
# Several low-level libraries other than OpenBLAS and LAPACK, as well as libraries that use OpenMP, respect this
# option as well. Use this option together with `ataccama.one.aicore.parallelism.jobs`.
# For more information, see the AI Core Sizing Guidelines.
# Refreshable: `False`.
ataccama.one.aicore.parallelism.omp=1

# An alternative way of setting the number of parallel threads spawned by low-level calculations that are
# used by machine learning algorithms.
# If the value is set to `0`, all CPU cores run without hyper-threads.
# If the value is not set (`null`), the dynamic API is not used. Relies on the dynamic OpenBLAS API, which has
# a higher overhead than the static API used by `ataccama.one.aicore.parallelism.omp`.
# When this property is set, OpenBLAS gives it higher priority compared to
# `ataccama.one.aicore.parallelism.omp` and `ataccama.one.aicore.parallelism.blas`.
# The dynamic API is intended only for exceptional cases and should not be used otherwise.
# Refreshable: `False`.
ataccama.one.aicore.parallelism.threads=null

# ----------------------------- TLS - out -----------------------------
# All client TLS options can be specified per connection. To set any TLS option for a specific client connection,
# configure the same set of properties as for the global client TLS configuration (properties with the `ataccama.client.tls` prefix).
# Depending on your setup, use one of the following prefixes:
# `ataccama.client.connection.<connection_name>.tls` for specifying TLS for connections using any communication protocol (gRPC and HTTP),
# `ataccama.client.connection.<connection_name>.grpc.tls` for specifying TLS for connections using the gRPC communication protocol,
# `ataccama.client.connection.<connection_name>.http.tls` for specifying TLS for connections using the HTTP communication protocol.
# If an option is not specified for the given client connection, global client TLS options are applied.
# Refreshable: `False`.
ataccama.client.connection=null

# All client TLS options can be specified directly for gRPC client. To set any TLS option for a gRPC client,
# configure the same set of properties as for the global client TLS configuration (properties with the `ataccama.client.tls` prefix),
# but use the prefix `ataccama.client.grpc.tls` instead.
# If an option is not specified for the gRPC client, global client TLS options are applied.
# Refreshable: `False`.
ataccama.client.grpc.tls=null

# All client TLS options can be specified directly for HTTP client. To set any TLS option for a HTTP client,
# configure the same set of properties as for the global client TLS configuration (properties with the `ataccama.client.tls` prefix),
# but use the prefix `ataccama.client.http.tls` instead.
# If an option is not specified for the HTTP client, global client TLS options are applied.
# Refreshable: `False`.
ataccama.client.http.tls=null

# Defines whether the gRPC and HTTP clients should use TLS when communicating with the servers.
# Refreshable: `False`.
ataccama.client.tls.enabled=False

# The private key name specified in the provided keystore that is used for TLS.
# Does not work with `PKCS12` format. To avoid unexpected behavior, use `PKCS12` with only one private key.
# Refreshable: `False`.
ataccama.client.tls.key-alias=null

# The password for the private key of the gRPC and HTTP clients. Used if the private key is encrypted.
# Does not work with `PKCS12` format. To avoid unexpected behavior, use `PKCS12` only with
# a non-encrypted private key.
# Refreshable: `False`.
ataccama.client.tls.key-password=null

# Points to the keystore containing private and public key certificates that are used by the gRPC and HTTP clients.
# For example, `file:${ataccama.path.etc}/key-store.pkcs12`.
# Refreshable: `False`.
ataccama.client.tls.key-store=null

# The password for the keystore. Used if the keystore is encrypted.
# Refreshable: `False`.
ataccama.client.tls.key-store-password=null

# The type of the keystore. Possible types are `PKCS12`, `JKS`, and `JCEKS`.
# Refreshable: `False`.
ataccama.client.tls.key-store-type=null

# Defines whether the gRPC and HTTP clients should use mTLS when communicating with the servers.
# Refreshable: `False`.
ataccama.client.tls.mtls=False

# Defines whether the gRPC and HTTP clients should verify the certificate of the server with which they
# communicate.
# Refreshable: `False`.
ataccama.client.tls.trust-all=False

# Points to the truststore with all the trusted certification authorities (CAs) used in gRPC and HTTP TLS
# communication. Used only when `tls.trust-all` is disabled.
# For example, `file:${ataccama.path.etc}/trust-store.pkcs12`.
# Refreshable: `False`.
ataccama.client.tls.trust-store=null

# The password for the truststore. Used if the truststore is encrypted.
# Refreshable: `False`.
ataccama.client.tls.trust-store-password=null

# The type of the truststore. Possible types are `PKCS12` and `JCEKS`.
# Refreshable: `False`.
ataccama.client.tls.trust-store-type=null

# ----------------------------- Authentication - in -----------------------------
# Enables basic authentication on the gRPC server. If enabled, Keycloak becomes a mandatory dependency
# - it needs to be running before the AI Core starts.
# Refreshable: `False`.
ataccama.authentication.grpc.basic.enable=True

# Enables bearer authentication on the gRPC server. If enabled, Keycloak becomes a mandatory dependency
# - it needs to be running before the AI Core starts.
# Refreshable: `False`.
ataccama.authentication.grpc.bearer.enable=True

# Enables internal JWT token authentication on the gRPC server.
# Refreshable: `False`.
ataccama.authentication.grpc.internal.jwt.enable=True

# If set to `false`, nobody is allowed to access any HTTP endpoint. To explicitly allow access to some endpoint,
# access based on allowed roles can be configured via `ataccama.authentication.http.acl.endpoints`.
# Refreshable: `False`.
ataccama.authentication.http.acl.default-allow=True

# Used for securing HTTP endpoints based on user/module roles. The role comparison is case-insensitive.
# Example for allowing only `ADMIN` roles to access prometheus endpoint:
# `ataccama.authentication.http.acl.endpoints.prometheus-endpoint.endpoint-filter=["/actuator/prometheus"]`,
# `ataccama.authentication.http.acl.endpoints.prometheus-endpoint.allowed-roles=["ADMIN"].
# Refreshable: `False`.
ataccama.authentication.http.acl.endpoints=null

# Enables basic authentication on the HTTP server. If enabled, Keycloak becomes a mandatory dependency
# - it needs to be running before the AI Core starts.
# Refreshable: `False`.
ataccama.authentication.http.basic.enable=True

# Ant-style patterns that filter which HTTP endpoints have basic authentication enabled.
# Individual patterns are separated by `;`.
# Refreshable: `False`.
ataccama.authentication.http.basic.endpoint-filter=/**

# Enables bearer authentication on the HTTP server. If enabled, Keycloak becomes a mandatory dependency
# - it needs to be running before the AI Core starts.
# Refreshable: `False`.
ataccama.authentication.http.bearer.enable=True

# Ant-style patterns that filter which HTTP endpoints have bearer authentication enabled.
# Individual patterns are separated by `;`.
# Refreshable: `False`.
ataccama.authentication.http.bearer.endpoint-filter=/**

# Enables internal JWT token authentication on the HTTP server.
# Refreshable: `False`.
ataccama.authentication.http.internal.jwt.enable=True

# Ant-style patterns that filter which HTTP endpoints have internal JWT authentication enabled.
# Individual patterns are separated by `;`.
# Refreshable: `False`.
ataccama.authentication.http.internal.jwt.endpoint-filter=/**

# Ant-style patterns that filter which public HTTP endpoints should be protected. These endpoint become
# no longer public and authentication is required. Individual patterns are separated by `;`.
# Refreshable: `False`.
ataccama.authentication.http.public-endpoint-restriction-filter=null

# Role used for validating that service that sends request to AI Core can impersonate a user.
# Refreshable: `False`.
ataccama.authentication.internal.jwt.impersonation-role=IMPERSONATION

# The name of the Keycloak realm. Used when requesting an access token during authorization.
# Refreshable: `False`.
#ataccama.authentication.keycloak.realm=

# The URL of the server where Keycloak is running.
# Refreshable: `False`.
#ataccama.authentication.keycloak.server-url=

# The expected recipients of the Keycloak token. Used to validate the access (bearer) token obtained from
# Keycloak. If the value is `null`, the audience is not verified.
# Refreshable: `False`.
ataccama.authentication.keycloak.token.audience=null

# The client token identifier of the AI Core module. Used when requesting an access token during authorization.
# Refreshable: `False`.
#ataccama.authentication.keycloak.token.client-id=

# The expected algorithm that was used to sign the access (bearer) token obtained from Keycloak.
# Refreshable: `False`.
ataccama.authentication.keycloak.token.expected-algorithm=RS256

# The issuer of the Keycloak token. Used to validate the access (bearer) token obtained from Keycloak.
# If the value is `null`, the issuer is not verified.
# Refreshable: `False`.
ataccama.authentication.keycloak.token.issuer=${ataccama.authentication.keycloak.server-url}/realms/${ataccama.authentication.keycloak.realm}

# Defines the minimum amount of time between two consecutive requests for Keycloak certificates during which
# Keycloak is not asked for new certificates. This acts as a prevention against DDoS attacks with an unknown key.
# Expressed in seconds.
# Refreshable: `False`.
ataccama.authentication.keycloak.token.key-cache-min-time-between-request=5

# Defines how long the public certificates from Keycloak are cached on the AI Core side.
# If this time is exceeded, new certificates are fetched from Keycloak before the AI Core makes an attempt to authenticate.
# If this time is not exceeded, but the public certificate for the key parsed from the authentication attempt was not found in the cache,
# new certificates are fetched from Keycloak and authentication is attempted again.
# Expressed in seconds.
# Refreshable: `False`.
ataccama.authentication.keycloak.token.key-cache-ttl=300

# The secret key of the AI Core client. Used when requesting an access token during authorization.
# Refreshable: `False`.
#ataccama.authentication.keycloak.token.secret=

# Deployment settings (with public JWT keys) for other modules communicating with AI Core.
# Required fields for deployment are: `module`, `uri`, `roles`. These fields are used for creation of
# service identity during authentication.
# Required fields for JWT key are: `fingerprint`, `content`. Optional `is-revoked` is used for revoking
# the corresponding JWT key (e.g. via Config Service) if the key was compromised.
# Example settings for MMM:
# `ataccama.one.platform.deployments.mmm-be.module=<value>`,
# `ataccama.one.platform.deployments.mmm-be.uri=<value>`,
# `ataccama.one.platform.deployments.mmm-be.security.roles=<value>`,
# `ataccama.one.platform.deployments.mmm-be.security.jwt-keys.mmm-key.fingerprint=<value>`,
# `ataccama.one.platform.deployments.mmm-be.security.jwt-keys.mmm-key.content=<value>`,
# `ataccama.one.platform.deployments.mmm-be.security.jwt-keys.mmm-key.is-revoked=false`.
# Refreshable: `True`.
ataccama.one.platform.deployments=null

# ----------------------------- Encryption -----------------------------
# Points to the keystore containing private and public key certificates that are used by the gRPC and HTTP clients.
# For example, `file:${ataccama.path.etc}/key-store.pkcs12`.
# Refreshable: `False`.
internal.encryption.key-store=null

# The password for the keystore. Used if the keystore is encrypted.
# Refreshable: `False`.
internal.encryption.key-store-password=null

# The type of the keystore. Possible types are `PKCS12`, `JKS`, and `JCEKS`.
# Refreshable: `False`.
internal.encryption.key-store-type=null

# Points to the keystore containing private and public key certificates that are used by the gRPC and HTTP clients.
# For example, `file:${ataccama.path.etc}/key-store.pkcs12`.
# Refreshable: `False`.
properties.encryption.key-store=null

# The password for the keystore. Used if the keystore is encrypted.
# Refreshable: `False`.
properties.encryption.key-store-password=null

# The type of the keystore. Possible types are `PKCS12`, `JKS`, and `JCEKS`.
# Refreshable: `False`.
properties.encryption.key-store-type=null

# ----------------------------- TLS - in -----------------------------
# All server TLS options can be specified directly for gRPC server. To set any TLS option for a gRPC server,
# configure the same set of properties as for the global server TLS configuration (properties with the `ataccama.server.tls` prefix),
# but use the prefix `ataccama.server.grpc.tls` instead.
# If an option is not specified for the gRPC server, global server TLS options are applied.
# Refreshable: `False`.
ataccama.server.grpc.tls=null

# All server TLS options can be specified directly for HTTP server. To set any TLS option for a HTTP server,
# configure the same set of properties as for the global server TLS configuration (properties with the `ataccama.server.tls` prefix),
# but use the prefix `ataccama.server.http.tls` instead.
# If an option is not specified for the HTTP server, global server TLS options are applied.
# Refreshable: `False`.
ataccama.server.http.tls=null

# Defines whether the gRPC and HTTP servers should generate their self-signed certificate.
# The private key is saved to a location specified by `ataccama.server.tls.private-key`
# and the certificate to a location specified by `ataccama.server.tls.cert-chain`.
# Refreshable: `False`.
ataccama.server.tls.allow-generate=False

# The path to the generated certificate of the gRPC and HTTP servers.
# For example, `file:${ataccama.path.etc}/server.crt`.
# Refreshable: `False`.
ataccama.server.tls.cert-chain=null

# Defines whether the gRPC and HTTP servers should use TLS authentication.
# Refreshable: `False`.
ataccama.server.tls.enabled=False

# The private key name specified in the provided keystore that is used for TLS.
# Does not work with `PKCS12` format. To avoid unexpected behavior, use `PKCS12` with only one private key.
# Refreshable: `False`.
ataccama.server.tls.key-alias=null

# The password for the private key of the gRPC and HTTP servers. Used if the private key is encrypted."
# Does not work with `PKCS12` format. To avoid unexpected behavior, use `PKCS12` only with
# a non-encrypted private key.
# Refreshable: `False`.
ataccama.server.tls.key-password=null

# Points to the keystore containing private and public key certificates that are used by the gRPC and HTTP servers.
# For example, `file:${ataccama.path.etc}/key-store.pkcs12`.
# Refreshable: `False`.
ataccama.server.tls.key-store=null

# The password for the keystore. Used if the keystore is encrypted.
# Refreshable: `False`.
ataccama.server.tls.key-store-password=null

# The type of the keystore. Possible types are `PKCS12`, `JKS`, and `JCEKS`.
# Refreshable: `False`.
ataccama.server.tls.key-store-type=null

# Defines whether the gRPC and HTTP servers require clients to be authenticated.
# Possible values are `NONE`, `OPTIONAL`, `REQUIRED`.
# Can be set to `REQUIRED` only if `ataccama.server.tls.trust-cert-collection` is specified as well.
# Refreshable: `False`.
ataccama.server.tls.mtls=OPTIONAL

# The path to the generated private key of the gRPC and HTTP servers.
# For example, `file:${ataccama.path.etc}/server.key`.
# Refreshable: `False`.
ataccama.server.tls.private-key=null

# Points to the truststore with all the trusted certification authorities (CAs) used in the gRPC and HTTP
# TLS communication. For example, `file:${ataccama.path.etc}/trust-store.pkcs12`.
# Refreshable: `False`.
ataccama.server.tls.trust-store=null

# The password for the truststore. Used if the truststore is encrypted.
# Refreshable: `False`.
ataccama.server.tls.trust-store-password=null

# The type of the truststore. Possible types are `PKCS12` and `JCEKS`.
# Refreshable: `False`.
ataccama.server.tls.trust-store-type=null

# ----------------------------- Security headers -----------------------------
# The value of the HTTP Strict-Transport-Security (HSTS) response header. Used only when HTTPS is enabled.
# Informs browsers that the resource should only be accessed using the HTTPS protocol.
# Refreshable: `False`.
ataccama.one.security.header.Strict-Transport-Security=max-age=31536000; includeSubDomains; preload

# ----------------------------- Supervisor -----------------------------
# A list of microservices whose stdout and stderr streams are forwarded to the respective stdout and stderr
# streams of the Supervisor process for debugging purposes.
# Refreshable: `False`.
ataccama.one.aicore.supervisor.captured-microservices=[]

# The network address to which the Supervisor HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.supervisor.http.server.listen-address=0.0.0.0

# The HTTP port where the Supervisor microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.supervisor.http.server.port=8040

# When the Supervisor runs a health check, this property controls for how long the Supervisor waits to receive
# data before cancelling the request. If the connection times out, the microservice is considered as no longer
# running. For more information, see the
# [Requests Developer Interface Documentation](https://requests.readthedocs.io/en/master/api/), section about the
# `timeout` parameter.
# Refreshable: `False`.
ataccama.one.aicore.supervisor.liveness.connection-timeout=5

# Determines how often a health check is performed. By default, this is done once every minute. Expressed in
# seconds.
# Refreshable: `False`.
ataccama.one.aicore.supervisor.liveness.interval=60

# Determines how many consecutive health checks need to fail, indicating that the microservice is no longer
# running, before the microservice is restarted.
# Refreshable: `False`.
ataccama.one.aicore.supervisor.liveness.retries=3

# Defines for how long the Supervisor waits after starting a microservice before it starts checking its health
# (a temporary workaround). Expressed in seconds.
# Refreshable: `False`.
ataccama.one.aicore.supervisor.liveness.start-delay=10

# Defines which microservices are started when the Supervisor is run.
# Refreshable: `False`.
ataccama.one.aicore.supervisor.microservices=["matching_manager", "anomaly_detector", "translator", "autocomplete", "spellchecker", "recommender", "neighbors", "feedback", "upgrade"]

# When the Supervisor is asked to shut down (for example, by pressing `Ctrl+C`), the service asks the
# microservices to shut down as well. This property defines how much time the microservices have to gracefully
# shut down before they are stopped.
# Refreshable: `False`.
ataccama.one.aicore.supervisor.shutdown-timeout=5

# ----------------------------- Term suggestions -----------------------------
# The IP address or the URL of the server where the Feedback microservice is running.
# Refreshable: `False`.
ataccama.client.connection.feedback.host=localhost

# The HTTP port of the server where the Feedback microservice is running.
# Refreshable: `False`.
ataccama.client.connection.feedback.http.port=8043

# The gRPC port of the server where the Neighbors microservice is running.
# Refreshable: `False`.
ataccama.client.connection.neighbors.grpc.port=8542

# The IP address or the URL of the server where the Neighbors microservice is running.
# Refreshable: `False`.
ataccama.client.connection.neighbors.host=localhost

# The HTTP port of the server where the Neighbors microservice is running.
# Refreshable: `False`.
ataccama.client.connection.neighbors.http.port=8042

# The IP address or the URL of the server where the Recommender microservice is running.
# Refreshable: `False`.
ataccama.client.connection.recommender.host=localhost

# The HTTP port of the server where the Recommender microservice is running.
# Refreshable: `False`.
ataccama.client.connection.recommender.http.port=8041

# The number of feedbacks for which thresholds are recomputed at once by the Feedback service. If the
# batch size is too small, the database is queried too often and the computation is inefficient. If the batch size
# is too large, the Feedback service can in turn require more memory resources.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.feedback.batch-size=10000

# The network address to which the Feedback gRPC server should bind.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.feedback.grpc.server.listen-address=0.0.0.0

# The port where the gRPC interface of the Feedback microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.feedback.grpc.server.port=8543

# The network address to which the Feedback HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.feedback.http.server.listen-address=0.0.0.0

# The HTTP port where the Feedback microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.feedback.http.server.port=8043

# The maximum number of fingerprints that can be present in the index used for searching neighbors.
# Once this value is reached, the microservice shuts down when trying to add new attributes. If the number
# of attributes in the database, including the deleted ones, exceeds the limit on startup, the microservice waits
# in the Not ready state indefinitely or until the number of attributes is reduced to this value or lower.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.neighbors.cache.attributes-limit=1000000

# The network address to which the Neighbors gRPC server should bind.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.neighbors.grpc.server.listen-address=0.0.0.0

# The port where the gRPC interface of the Neighbors microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.neighbors.grpc.server.port=8542

# The network address to which the Neighbors HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.neighbors.http.server.listen-address=0.0.0.0

# The HTTP port where the Neighbors microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.neighbors.http.server.port=8042

# The number of attributes for which term suggestions are recomputed at once by the Recommender service. If the
# batch size is too small, the database is queried too often and the computation is inefficient. If the batch size
# is too large, the process can take a long time, which in turn can render the Recommender unresponsive for the
# duration of the request and require more memory resources.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.recommender.batch-size=1000

# The default starting distance threshold for newly created terms. The distance threshold defines how close
# the fingerprints need to be so that, if one of them has some terms assigned, the AI Core suggests those terms
# to the other one as well. It also affects the confidence of suggestions.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.recommender.default-threshold=1.0

# The network address to which the Recommender gRPC server should bind.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.recommender.grpc.server.listen-address=0.0.0.0

# The port where the gRPC interface of the Recommender microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.recommender.grpc.server.port=8541

# The network address to which the Recommender HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.recommender.http.server.listen-address=0.0.0.0

# The HTTP port where the Recommender microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.recommender.http.server.port=8041

# Sets the highest possible value for the similarity threshold (see the `recommender.target-accuracy` property).
# This value cannot be surpassed even when users consistently accept all term suggestions, which results
# in the AI Core attempting to further expand the threshold in order to lower the acceptance rate and meet
# the target accuracy.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.recommender.max-threshold=16

# The target ratio of term suggestions that users approved to the total number of suggestions, both approved and
# rejected, that the AI Core is trying to achieve. This is done by slowly adapting the similarity threshold for
# each term over time.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.recommender.target-accuracy=0.8

# The speed at which the similarity threshold is adapted. The similarity threshold has a role in reaching the
# set `recommender.target-accuracy`.
# Refreshable: `False`.
ataccama.one.aicore.term-suggestions.recommender.threshold-step=0.1

# The maximum size of gRPC message. KB are used if no unit is specified.
# Refreshable: `False`.
ataccama.server.grpc.properties.max-message-size=1GB

# ----------------------------- NLP search -----------------------------
# The gRPC port of the server where the Autocomplete microservice is running.
# Refreshable: `False`.
ataccama.client.connection.autocomplete.grpc.port=8545

# The IP address or the URL of the server where the Autocomplete microservice is running.
# Refreshable: `False`.
ataccama.client.connection.autocomplete.host=localhost

# The HTTP port of the server where the Autocomplete microservice is running.
# Refreshable: `False`.
ataccama.client.connection.autocomplete.http.port=8045

# The gRPC port of the server where the Spellchecker microservice is running.
# Refreshable: `False`.
ataccama.client.connection.spellchecker.grpc.port=8544

# The IP address or the URL of the server where the Spellchecker microservice is running.
# Refreshable: `False`.
ataccama.client.connection.spellchecker.host=localhost

# The HTTP port of the server where the Spellchecker microservice is running.
# Refreshable: `False`.
ataccama.client.connection.spellchecker.http.port=8044

# The gRPC port of the server where the Translator microservice is running.
# Refreshable: `False`.
ataccama.client.connection.translator.grpc.port=8546

# The IP address or the URL of the server where the Translator microservice is running.
# Refreshable: `False`.
ataccama.client.connection.translator.host=localhost

# The HTTP port of the server where the Translator microservice is running.
# Refreshable: `False`.
ataccama.client.connection.translator.http.port=8046

# The network address to which the Autocomplete gRPC server should bind.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.autocomplete.grpc.server.listen-address=0.0.0.0

# The port where the gRPC interface of the Autocomplete microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.autocomplete.grpc.server.port=8545

# The network address to which the Autocomplete HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.autocomplete.http.server.listen-address=0.0.0.0

# The HTTP port where the Autocomplete microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.autocomplete.http.server.port=8045

# A JSON definition of the relation between search template placeholders and entity types.
# Refreshable: `True`.
ataccama.one.aicore.nlp-search.nodes-to-request=[\
    {\
        "placeholder_value": "source",\
        "entity_request": "sources"\
    },\
    {\
        "placeholder_value": "term",\
        "entity_request": "terms"\
    }\
]

# A JSON definition of search suggestions templates.
# Refreshable: `True`.
ataccama.one.aicore.nlp-search.query-parts-config={\
    "with term": {\
        "value": "term",\
        "AQL": {\
            "catalogItem": "(termInstances.some(target{name like ${term} OR synonym like ${term} OR abbreviation like ${term}}) OR attributes.some(termInstances.some(target{name like ${term} OR synonym like ${term} OR abbreviation like ${term}})))",\
            "source": "locations.some(catalogItems.some(termInstances.some(target{name like ${term}}))) OR locations.some(locations.some(catalogItems.some(termInstances.some(target{name like ${term}}))))"\
        },\
        "allow_negations": true\
    },\
    "from source": {\
        "value": "source",\
        "AQL": {\
            "catalogItem": "($parent.$parent.name like ${source} OR $parent.$parent.$parent.name like ${source} OR $parent.$parent.$parent.$parent.name like ${source})"\
        },\
        "allow_negations": true\
    },\
    "with attribute": {\
        "value": "attribute",\
        "AQL": {\
            "catalogItem": "attributes.some(name like ${attribute})"\
        },\
        "allow_negations": true\
    },\
    "fulltext": {\
        "value": "anything",\
        "AQL": {\
            "all": "$fulltext like ${anything}"\
        }\
    }\
}

# Defines how often requests are sent to MMM to retrieve metadata entity names, such as names of terms and
# sources, which are used for autocomplete.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.request-metadata-period-s=60

# The network address to which the Spellchecker gRPC server should bind.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.spellchecker.grpc.server.listen-address=0.0.0.0

# The port where the gRPC interface of the Spellchecker microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.spellchecker.grpc.server.port=8544

# The network address to which the Spellchecker HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.spellchecker.http.server.listen-address=0.0.0.0

# The HTTP port where the Spellchecker microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.spellchecker.http.server.port=8044

# A list of languages used for AQL error checking. For every stated language, a file named
# `<language_name>_word_frequencies.txt` is searched for in the vocabularies folder.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.spellchecker.languages=["english"]

# Points to the location of vocabularies used for AQL error checking.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.spellchecker.vocabularies-folder=${ataccama.path.etc}/data/nlp_search

# The network address to which the Translator gRPC server should bind.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.translator.grpc.server.listen-address=0.0.0.0

# The port where the gRPC interface of the Translator microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.translator.grpc.server.port=8546

# The network address to which the Translator HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.translator.http.server.listen-address=0.0.0.0

# The HTTP port where the Translator microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.nlp-search.translator.http.server.port=8046

# ----------------------------- Anomaly detection -----------------------------
# The IP address or the URL of the server where the Anomaly Detector microservice is running.
# Refreshable: `False`.
ataccama.client.connection.anomaly-detector.host=localhost

# The HTTP port of the server where the Anomaly Detector microservice is running.
# Refreshable: `False`.
ataccama.client.connection.anomaly-detector.http.port=8047

# The network address to which the Anomaly Detector gRPC server should bind.
# Refreshable: `False`.
ataccama.one.aicore.anomaly-detection.anomaly-detector.grpc.server.listen-address=0.0.0.0

# The port where the gRPC interface of the Anomaly Detector microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.anomaly-detection.anomaly-detector.grpc.server.port=8547

# The network address to which the Anomaly Detector HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.anomaly-detection.anomaly-detector.http.server.listen-address=0.0.0.0

# The HTTP port where the Anomaly Detector microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.anomaly-detection.anomaly-detector.http.server.port=8047

# An internal parameter for the time-independent anomaly detection model (Isolation Forest) that defines the
# sensitivity of anomaly detection. Setting the value higher than the default value (for example, -0.5) can
# result in more false positive anomalies, while setting it lower than the default value (for example, -0.7) can
# lead to more false negative anomalies.
# Refreshable: `False`.
ataccama.one.aicore.anomaly-detection.anomaly-detector.isolation-forest-threshold=-0.6

# The maximum number of catalog item profile versions fetched from MMM on which anomaly detection is run. If
# the total number of profile versions in MMM exceeds the value set for this property, the versions are retrieved
# starting from the most recent. For example, if there are 30 profile versions in MMM and the property is set to
# 100, all 30 versions are fetched. However, if there are 200 profile versions in MMM and the value provided is
# 100, the last 100 profile versions are retrieved.
# Refreshable: `False`.
ataccama.one.aicore.anomaly-detection.anomaly-detector.max-history-length=100

# An internal parameter for the time-dependent anomaly detection model (time series analysis) that defines the
# sensitivity of anomaly detection. The property describes the number of standard deviations (std) from the mean
# after which a point is considered as anomalous. Setting the value higher than the default value (for example, 4)
# reduces the total number of anomalies and results in more false negative anomalies, while setting it lower than
# the default value (for example, 2) increases the total number of detected anomalies and results in more false
# positive anomalies.
# Refreshable: `False`.
ataccama.one.aicore.anomaly-detection.anomaly-detector.time-series-std-threshold=3.0

# ----------------------------- AI Matching -----------------------------
# The gRPC port of the server where the Matching Manager microservice is running.
# Refreshable: `False`.
ataccama.client.connection.matching-manager.grpc.port=8640

# The IP address or the URL of the server where the Matching Manager microservice is running.
# Refreshable: `False`.
ataccama.client.connection.matching-manager.host=localhost

# The HTTP port of the server where the Matching Manager microservice is running.
# Refreshable: `False`.
ataccama.client.connection.matching-manager.http.port=8140

# The gRPC port of the server where the MDC is running.
# Refreshable: `False`.
ataccama.client.connection.mdc.grpc.port=18581

# The IP address or the URL of the server where the MDC is running.
# Refreshable: `False`.
ataccama.client.connection.mdc.host=localhost

# The network address to which the Matching Manager gRPC server should bind.
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching-manager.grpc.server.listen-address=0.0.0.0

# The port where the gRPC interface of the Matching Manager microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching-manager.grpc.server.port=8640

# The network address to which the Matching Manager HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching-manager.http.server.listen-address=0.0.0.0

# The HTTP port where the Matching Manager microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching-manager.http.server.port=8140

# The dedupe clustering decision threshold that functions as a compromise between precision and recall. The value needs to be between `0` and `1`. Increasing the value means a higher precision and lower recall, that is, fewer `MERGE` proposals and more `SPLIT` proposals. Inversely, decreasing the value results in a lower level of precision and higher recall.
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching_steps.clustering.decision_threshold=0.5

# The number of groups or clusters that are processed in a single batch when proposals are generated during the AI Matching evaluation. A higher number means that the processing is more efficient but requires more memory (RAM).
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching_steps.evaluation.groups_fetching_batch_size=100

# The number of proposals that are processed in a single batch when proposals are scored during the AI Matching evaluation. A higher number means that the processing is more efficient but requires more memory (RAM).
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching_steps.evaluation.scoring_batch_size=5000

# The number of records that are uniformly sampled from all the records fetched from MDM. Those records are the only ones used for initializing and training the AI Matching model.
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching_steps.initialization.sample_size=1000000

# The number of records that the AI Matching selects out of the records covered by the property `ai-matching.matching_steps.initialization.sample_size` for the actual training of the AI model. A higher value means that the model performs better, but the training takes more time.
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching_steps.initialization.training_sample_size=40000

# The maximum number of columns in one extracted rule. A higher number means that the extracted rules can be
# more complex, that is, use more columns, but the rule extraction might take significantly longer.
# Refreshable: `False`.
ataccama.one.aicore.ai-matching.matching_steps.rules_extraction.max_columns=5

# ----------------------------- Migration -----------------------------
# The IP address or the URL of the server where the Upgrade microservice is running.
# Refreshable: `False`.
ataccama.client.connection.upgrade.host=localhost

# The HTTP port of the server where the Upgrade microservice is running.
# Refreshable: `False`.
ataccama.client.connection.upgrade.http.port=8141

# The network address to which the Upgrade HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.migration.upgrade.http.server.listen-address=0.0.0.0

# The HTTP port where the Upgrade microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.migration.upgrade.http.server.port=8141

# ----------------------------- Metadata fetching -----------------------------
# Defines the method of creating the metadata dump output. Possible values: `s3`, `fs`.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.dump-method=s3

# A list of entity types defining entity instances which should be fetched from MMM. Empty list means all
# entity types. If not empty, all entity types from the list and all entity types reachable from this list by
# properties defined in ataccama.one.aicore.metadata-fetcher.traversed_properties will be fetched.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.fetched-entities=["catalogItem"]

# File path of the metadata dump in the file system.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.fs.dump-path=metadata.json

# Name of a bucket in the S3 service to dump the metadata into.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.s3.bucket=null

# Access key (aka user ID) of an account in S3 service.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.s3.credentials.access-key=null

# Secret Key (aka password) of an account in S3 service.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.s3.credentials.secret-key=null

# File path of the metadata dump in the S3 bucket.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.s3.dump-path=metadata.json

# S3 endpoint used to dump the metadata.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.s3.endpoint=null

# Region name of a bucket in S3 service.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.s3.region=null

# Defines whether the Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3) is used.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.s3.sse.enabled=True

# Defines whether the minio client should use TLS when communicating with the S3 service.
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.s3.tls.enabled=True

# A list of properties which will be used to traverse the meta-metadata structure to determine entity types
# to fetch - see ataccama.one.aicore.metadata-fetcher.fetched_entities. Possible values are:
# "SE" (Single embedded), "AE" (Array embedded), "SR" (Single reference).
# Refreshable: `False`.
ataccama.one.aicore.metadata-fetcher.traversed-properties=["SE", "AE"]

# ----------------------------- CLI Client -----------------------------
# The IP address or the URL of the server where the CLI Client microservice is running.
# Refreshable: `False`.
ataccama.client.connection.cli-client.host=localhost

# The HTTP port of the server where the CLI Client microservice is running.
# Refreshable: `False`.
ataccama.client.connection.cli-client.http.port=9041

# The IP address or the URL of the server where the CLI GraphQL is running.
# Refreshable: `False`.
ataccama.client.connection.cli-graphql.host=localhost

# The HTTP port of the server where the CLI GraphQL is running.
# Refreshable: `False`.
ataccama.client.connection.cli-graphql.http.port=8021

# The gRPC port of the server where the CLI Server microservice is running.
# Refreshable: `False`.
ataccama.client.connection.cli-server.grpc.port=9540

# The IP address or the URL of the server where the CLI Server microservice is running.
# Refreshable: `False`.
ataccama.client.connection.cli-server.host=localhost

# The HTTP port of the server where the CLI Server microservice is running.
# Refreshable: `False`.
ataccama.client.connection.cli-server.http.port=9040

# The network address to which the CLI Client HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.cli-client.http.server.listen-address=0.0.0.0

# The HTTP port where the CLI Client microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.cli-client.http.server.port=9041

# ----------------------------- CLI Server -----------------------------
# The network address to which the CLI Server gRPC server should bind.
# Refreshable: `False`.
ataccama.one.aicore.cli-server.grpc.server.listen-address=0.0.0.0

# The port where the gRPC interface of the CLI Server microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.cli-server.grpc.server.port=9540

# The network address to which the CLI Server HTTP server should bind.
# Refreshable: `False`.
ataccama.one.aicore.cli-server.http.server.listen-address=0.0.0.0

# The HTTP port where the CLI Server microservice is running.
# Refreshable: `False`.
ataccama.one.aicore.cli-server.http.server.port=9040
